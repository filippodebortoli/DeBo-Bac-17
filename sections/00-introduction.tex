\section{Introduction}

\nocite{Winskel1993}
\nocite{Hemerik1988}

In denotational semantics, as well as in type theory, recursive specifications play a crucial role in establishing what can be achieved by the described programming languages.

% Recursive domain equations arise in many areas of denotational semantics and type theory, two of the mathematical fields that lay down the theoretical foundations of programming languages.
%
A common situation we may be faced with is that of recursion over \emph{values}: indeed, most of programming languages allow recursive programs, such as
\begin{displayquote}
  \texttt{P(n) = if n = 0 then 1 else nP(n-1);}
\end{displayquote}
which defines \(f \colon \mathbb{N} \to \mathbb{N}\) as \(f(n) := n!\).
In this context, mathematical structures like \(\omega\)--cpos permit to formalize this kind of recursion.
Here, this is achieved by defining the program as the least fixed point of the function
\begin{equation*}
  \begin{split}
    g \colon (\mathbb{N} \rightharpoonup \mathbb{N}_\bot) &\to (\mathbb{N} \rightharpoonup \mathbb{N}_\bot) \\
    g(h) &= \left(n \mapsto \begin{cases}1 & n = 0 \\ n\cdot h(n-1) & n > 0\end{cases}\right)
  \end{split}
\end{equation*}

Another scenario that frequently arises is that of a typed programming language which includes recursive specifications of datatypes.
While basic types, like natural numbers or boolean values, can be easily modelled according to set theory, recursive datatypes do not generally fit into this theory.
For example, given a type \(A\),
\begin{equation*}
  X_A = X_A \to A,
\end{equation*}
the recursive type of auto--applying functions returning a term in \(A\), cannot be a set if \(\lvert A \rvert \ge 2\), due to Cantor's theorem.
As we would like to take the ``least fixed point'' in this case, a more general and appropriate mathematical framework is needed.

Category theory, where type theory can be used as a syntactical tool to describe the construction of objects and morphisms, has been thereby used to extend the classical least fixed point theory over \(\omega\)--cpos to other classes of domains.
% A common situation may be that of a typed programming language featuring some basic types, for example, the set of natural numbers \(\mathbb{N}\) or the set of truth values \(\mathbb{B} = \lbrace \mathbb{F}, \mathbb{T} \rbrace\), and some compound ones, like the product type \(A \times B\), with \(A\) and \(B\) simple types. %chktex 21
% There exist suitable mathematical structures, which allow us to effectively describe recursively--defined programs in terms of fixed points of a function \(f\) ranging over a meaning domain \(D\); \(\omega\)--cpos have been the prevalent choice for some time, when dealing with recursion over \emph{values}.
%
% However, there are also programming languages that permit a recursive specification of data types, through fixed--point equations, thus introducing recursion over \emph{domains}
% A meaningful example is provided by the equation
% \begin{equation*}
%   X_A = X_A \to A
% \end{equation*}
% which describes auto--applying functions over a domain \(A\).
% If \(\lvert A \rvert \ge 2\), then \(X_A\) cannot be a set, due to Cantor's theorem --- indeed, \(\lvert X_A \rvert \ge 2^{\lvert X_A \rvert}\) is false whenever \(X_A\) is a set.
%
% A viable and powerful way to solve recursive domain equations is provided by category theory, which builds upon least fixed point theory over \(\omega\)--cpos to provide a canonical construction for the solution of those equations.
In the next chapters, we are going to review the main results of fixed point theory for \(\omega\)--cpos and categories; then, we will introduce \(\mathbf{O}\)--categories and embedding--projection pairs and we will show how a least fixed point can be taken in this framework.
Finally, we will discuss some isomorphic relations arising in some \(\mathbf{O}\)--categories and show how desirable features of programming languages find a natural place in the theory we presented.
